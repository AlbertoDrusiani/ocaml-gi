open API
open ModulePath
(*open Naming*)
(*open Util*)
(*open ModulePath*)
open GIR.BasicTypes
open Config

type code = Code of (code_token list)


and code_token =
      | Line of string
      | Indent of code
      | Group of code
      | IncreaseIndent


let getCode c =
  match c with
  | Code x -> x

let emptyCode =
  Code []


let isCodeEmpty c =
    match c with
    | Code seq_ -> List.length seq_ == 0


let codeSingleton t =
  Code [t]


type named_section =
  | MethodSection
  | PropertySection
  | SignalSection
  | EnumSection
  | FlagSection


type haddock_section =
  | ToplevelSection
  | NamedSubsection of named_section*string


type deps =
  StringSet.t

type symbol_name = string


type export_type =
  | ExportSymbol of haddock_section
  | ExportTypeDecl
  | ExportModule


type export =
  { exportType: export_type;
    exportSymbol: symbol_name;
  }


type module_info =
  { modulePath: module_path;
    moduleCode: code;
    bootCode: code;
    gCode: code;
    cCode: code;
    hCode: code;
    tCode: code;
    submodules: module_info StringMap.t;
    moduleDeps: deps; 
    cDeps: deps;
    moduleExports: export list;
    qualifiedImports: ModulePathSet.t;
    (*sectionDocs*)
  }


type module_flag = ImplicitPervasives

let emptyModule m =
  { modulePath = m;
    moduleCode = emptyCode;
    bootCode = emptyCode;
    cCode = emptyCode;
    tCode = emptyCode;
    hCode = emptyCode;
    gCode = emptyCode;
    submodules = StringMap.empty;
    moduleDeps = StringSet.empty;
    cDeps = StringSet.empty;
    moduleExports = [];
    qualifiedImports = ModulePathSet.empty;
   (* sectionDocs = *)
  }


type code_gen_config = {
  hConfig: config;
  loadedAPIs: api NameMap.t;
  (*c2hMap: TODO da implementare il modulo gtk-doc*) 
}

type cg_error =
  | CGErrorNonImplemented of string
  | CGErrorBadIntrospectionInfo of string
  | CGErrorMissingInfo of string


type named_tyvar =
  | SingleCharTyvar of char
  | IndexedTyvar of string*int

type cg_state = {
  cgsNextAvailableTyvar: named_tyvar;
}

let emptyCGState =
  {cgsNextAvailableTyvar = SingleCharTyvar 'b'}


(*let evalCodeGen cfg apis mPath cg =
  let initialInfo = emptyModule mPath in
  let cfg' = {hConfig = cfg; loadedAPIs = apis} in
  unwrapCodeGen cg cfg' (emptyCGState, initialInfo)
*)

 (*TODO questa è la funzione che mi faccio per creare il contesto per poi passarlo in giro
   * la semantica dovrebbe essere simile allo stato della monade. Sta roba viene fatta
   * nell'evalCodegen in Haskell, potevo chiamarla così ma qua non valuto niente*)
  (* config -> Map (name, api) -> module_path -> (codegen_config, cgstate, module_info)*)
  
let setContext cfg apis mPath =
    let initialInfo = emptyModule mPath in
    let cfg' = { hConfig = cfg; loadedAPIs = apis; (*c2hMap = cToHaskellMap (NameMap.to_seq apis |> List.of_seq)*)} in
     cfg', emptyCGState, initialInfo 


let rec mergeInfoState oldState newState =
  let newDeps = StringSet.union (oldState.moduleDeps) (newState.moduleDeps) in
  let newCDeps = StringSet.union (oldState.cDeps) (newState.cDeps) in
  let union_f _ m1 m2 = Some (mergeInfo m1 m2) in
  let newSubmodules = StringMap.union union_f oldState.submodules newState.submodules in
  let newExports = oldState.moduleExports @ newState.moduleExports in
  let newImports = ModulePathSet.union oldState.qualifiedImports newState.qualifiedImports in
  let newCCode = Code ((getCode oldState.cCode) @ (getCode newState.cCode)) in
  let newHCode = Code ((getCode oldState.hCode) @ (getCode newState.hCode)) in
  let newTCode = Code ((getCode oldState.tCode) @ (getCode newState.tCode)) in
  let newGCode = Code ((getCode oldState.gCode) @ (getCode newState.gCode)) in
  let newBoot = Code ((getCode oldState.bootCode) @ (getCode newState.bootCode)) in
  {oldState with 
   moduleDeps = newDeps;
   cDeps = newCDeps;
   submodules = newSubmodules;
   moduleExports = newExports;
   qualifiedImports = newImports;
   bootCode = newBoot;
   cCode = newCCode;
   tCode = newTCode;
   hCode = newHCode;
   gCode = newGCode;
  }

and mergeInfo oldInfo newInfo =
  let info = mergeInfoState oldInfo newInfo in
  { info with moduleCode = Code (getCode (oldInfo.moduleCode) @ getCode (newInfo.moduleCode))}

let addSubmodule minfo mName smInfo =
  match StringMap.mem mName minfo.submodules with
  | true -> {minfo with submodules = StringMap.add mName (mergeInfo smInfo minfo) minfo.submodules} 
  | false -> {minfo with submodules = StringMap.add mName smInfo minfo.submodules}


(*TODO qua viene fatta la runCodeGen e può sollevarsi un errore, gestisco in seguito*)
(*FIXME sta roba è bacatissima sicuro, manca la gestione del cgstate e la runcodegen come funziona?*)
let submodule' minfo mName =
  let info = emptyModule ({modulePathToList = minfo.modulePath.modulePathToList @ [mName]}) in
  addSubmodule minfo mName info



let rec submodule cfg cgstate minfo mPath =
  match mPath.modulePathToList with
  | [] -> minfo
  | m::ms -> submodule' (submodule minfo {modulePathToList = ms}) m



let tellHCode minfo c =
  match minfo.hCode with
  | Code cd -> { minfo with hCode = Code (cd @  [c])}


let hline minfo s =
  tellHCode minfo (Line s)




